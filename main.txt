#Importación de bibliotecas
import numpy as np 
import pandas as pd 
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error
from sklearn.metrics import mean_absolute_error
import yfinance as yf
from sklearn.preprocessing import MinMaxScaler 
from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout
import math
import warnings
warnings.filterwarnings('ignore')

#Descarga de datos del mercado con yfinance
datos = yf.download('TSLA').reset_index()
datos = datos[(datos['Date'] >= "2014-01-01") & (datos['Date'] <= "2023-12-12")].reset_index(drop=True)

#PREPARACIÓN DE LOS DATOS

# Trazado de los precios de cierre a través del tiempo
plt.plot(datos["Date"], datos["Close"])
plt.title("Precio de la acción de Tesla")
plt.xlabel("Tiempo")
plt.ylabel("Precio")
plt.show()

# Escalado de los precios de cierre
# MinMaxScaler => y = (y - min(y))/(min(y) - max(y))
scaler = MinMaxScaler(feature_range=(0,1))
datos['valores_escalados'] = scaler.fit_transform(datos['Close'].values.reshape(-1,1))

# División de los datos en conjuntos de entrenamiento y prueba
datos_entrenamiento = datos[datos['Date'] < '2023-01-01'] datos_prueba = datos[datos['Date'] >= '2023-01-01']

#Trazado de los datos de entrenamiento/datos de prueba
plt.figure(figsize=(10,6))
plt.grid(True)
plt.xlabel('Tiempo')
plt.ylabel('Precios de cierre')
plt.plot(datos_entrenamiento['Date'], datos_entrenamiento['Close'], 'green', label='Datos de entrenamiento')
plt.plot(datos_prueba['Date'], datos_prueba['Close'], 'blue', label='Datos de prueba')
plt.legend()
plt.show()

#Conversión de datos de entrenamiento a formato de matriz 3D
x_entrenamiento = []
y_entrenamiento = []

for i in range(60, len(datos_entrenamiento['valores_escalados'])):
    x_entrenamiento.append(datos_entrenamiento['valores_escalados'][i-60:i])
    y_entrenamiento.append(datos_entrenamiento['valores_escalados'][i])
    
x_entrenamiento = np.array(x_entrenamiento)
y_entrenamiento = np.array(y_entrenamiento)

# Converción de los datos nuevamente a una matriz 3D según lo requiere LSTM
x_entrenamiento = np.reshape(x_entrenamiento, (x_entrenamiento.shape[0], x_entrenamiento.shape[1], 1))

x_prueba = []
y_prueba = datos_prueba['valores_escalados']

for i in range(60, len(datos_prueba)):
    x_prueba.append(datos_prueba['valores_escalados'][i-60:i])

x_prueba = np.array(x_prueba)
x_prueba = np.reshape(x_prueba, (x_prueba.shape[0], x_prueba.shape[1], 1))


from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout

# Definición de la arquitectura del modelo LSTM----------------------------------

# Inicialización del modelo
modelo = Sequential()

# Capa 1 del LSTM
modelo.add(LSTM(units = 50, return_sequences = True, input_shape = (x_entrenamiento.shape[1], 1)))
modelo.add(Dropout(0.25))

# Capa 2 del LSTM
modelo.add(LSTM(units = 50, return_sequences = True))
modelo.add(Dropout(0.25))

# Capa 3 del LSTM
modelo.add(LSTM(units = 50, return_sequences = True))
modelo.add(Dropout(0.25))

# Capa 4 del LSTM
modelo.add(LSTM(units = 50))
modelo.add(Dropout(0.25))

# Capa final
modelo.add(Dense(units = 1))
modelo.summary()

#Compilación del modelo
modelo.compile(optimizer = 'adam', loss = 'mean_squared_error')

#Entrenamiento del modelo
modelo.fit(x_entrenamiento, y_entrenamiento, epochs = 10, batch_size = 32)

#Predicción con base en los datos de prueba
prediccion_precio_accion = modelo.predict(x_prueba)
prediccion_precio_accion = scaler.inverse_transform(prediccion_precio_accion)

#Trazado de las series en un mismo gráfico
plt.figure(figsize=(10,5), dpi=100)
plt.plot(datos_entrenamiento['Date'], datos_entrenamiento['Close'], label='Datos de entrenamiento')
plt.plot(datos_prueba['Date'], datos_prueba['Close'], color = 'blue', label='Precio actual del activo')
plt.plot(datos_prueba[60:]['Date'], prediccion_precio_accion, color = 'orange',label='Precio pronosticado del activo')

plt.title('Predicción del precio de un activo')
plt.xlabel('Tiempo')
plt.ylabel('Precio del activo')
plt.legend(loc='upper left', fontsize=8)
plt.show()

#Comparación de la precisión/error real del modelo
datos_y_verdaderos = datos_prueba[60:]['Close'].values
datos_y_predichos = prediccion_precio_accion

#Reporte de desempeño
mse = mean_squared_error(datos_y_verdaderos, datos_y_predichos)
print('MSE: '+str(mse))
mae = mean_absolute_error(datos_y_verdaderos, datos_y_predichos)
print('MAE: '+str(mae))
rmse = math.sqrt(mean_squared_error(datos_y_verdaderos, datos_y_predichos))
print('RMSE: '+str(rmse))
mape = np.mean(np.abs(datos_y_predichos - datos_y_verdaderos)/np.abs(datos_y_verdaderos))
print('MAPE: '+str(mape))